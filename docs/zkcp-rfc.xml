<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC3552 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3552.xml">
<!ENTITY RFC4422 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4422.xml">
<!ENTITY RFC5226 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml">
<!ENTITY RFC7414 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7414.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<rfc category="info" docName="draft-zkcp-rfc" ipr="noDerivativesTrust200902">

  <front>
    <title abbrev="ZooKeeper Client Protocol">ZooKeeper Client Protocol</title>

    <author fullname="Diego Ongaro" role="editor" surname="Ongaro">
      <organization>Salesforce</organization>
      <address>
        <postal>
          <street>The Landmark @ One Market</street>
          <street>Suite 300</street>
          <city>San Francisco</city>
          <region>CA</region>
          <code>94105</code>
          <country>USA</country>
        </postal>
        <email>dongaro@salesforce.com</email>
      </address>
    </author>

    <date year="2016" month="October" />

    <area>General</area>

    <!-- Later: Internet Engineering Task Force? -->
    <workgroup>Salesforce Internal </workgroup>

    <abstract>
      <t>This document is a draft describing the protocol used between Apache ZooKeeper (TM) clients and servers to query and manipulate data stored in a ZooKeeper cluster.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>ZooKeeper stores coordination data on a group of servers for clients to access. Clients access and modify the data by connecting to any server in the group and issuing requests.</t>

      <t>ZooKeeper clients typically access ZooKeeper servers using a client library, such as the Java or C clients included in Apache ZooKepeer or an "unofficial" client library. While several unofficial client libraries exist, the protocol they use has not been documented precisely until now. This document aims to document the existing protocol to promote interoperability across client library and server implementations.</t>

      <t>ZooKeeper clients and servers exchange discrete <spanx>packets</spanx> over <xref target="RFC7414">TCP</xref> connections. They frame each packet by prepending the length of the packet, as described in <xref target="framing" />.</t>

      <t>The contents of each packet are encoded using a format called Jute, as described in <xref target="jute" />.</t>

      <t>Basic data types that are used widely are introduced in <xref target="types" />.</t>

      <section title="Conventions">
        <t>The terminology used in Apache ZooKeeper is preferred.</t>

        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
          "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
          document are to be interpreted as described in <xref
          target="RFC2119">RFC 2119</xref>.</t>
        </section>
      </section>

      <section anchor="framing" title="Packet Framing">
        <t>Every packet sent by a ZooKeeper client or server is preceded by 4 bytes indicating the length of the data in the packet. The length is encoded in network byte order (big endian).</t>

        <t>TODO: is 0 length ok? how big can a packet be?</t>

        <figure align="left">
          <artwork align="left"><![CDATA[
+-----------+----------------+
|  length   |     data       |
| (4 bytes) | (length bytes) |
+-----------+----------------+]]></artwork>
        </figure>
      </section>

      <section anchor="jute" title="Jute Encoding">
        <t>Jute is a simple encoding scheme that assumes the recipient knows the exact schema for the data. The following types are defined and used in the ZooKeeper client protocol.</t>

        <section title="Booleans">
          <t>True is encoded as a single byte with value 1. False is encoded as the single byte with value 0.</t>
        </section>

        <section title="Signed Integers">
          <t>A 32-bit signed integer is encoded as four bytes in network byte order. A 64-bit signed integer is encoded as eight bytes in network byte order.</t>
        </section>

        <section title="Strings and Byte Arrays">
          <t>A string or byte array is encoded as its length in bytes as a 32-bit signed integer, followed by the bytes themselves. TODO: or is it length in unichode char points for strings?</t>

          <t>A byte array of 0 length is encoded as the four bytes 0xFF 0xFF 0xFF 0xFF. TODO: really? why?</t>
        </section>

        <section title="Arrays">
          <t>An array is encoded as its number of elements as a 32-bit signed integer, followed by each element in turn.</t>
        </section>

        <section title="Structs">
          <t>Structs are encoded as each field in turn in the order specified. As there is no special header, footer, or delimiter, some structs exist for documentation purposes only.</t>
        </section>
      </section>

      <section anchor="types" title="Basic Data Types">
        <t>TODO: might not need this</t>
      </section>

      <section anchor="sessions" title="Session Management">

        <section title="Initial Connection Setup">

          <t>Clients connect to a server of their choice over TCP and immediately issue a Connect Request (preceded by the size in bytes of the Connect Request, as described in <xref target="framing" />, and encoded with Jute, as described in <xref target="jute" />). Clients may send a ConnectRequestV1 or a ConnectRequestV2, which adds an additional 'readOnly' field.</t>

          <figure>
            <artwork><![CDATA[
  struct ConnectRequestV1 {
    sint32 protocolVersion
    sint64 lastZxidSeen
    sint32 timeOut
    sint64 sessionId
    byte[] passwd
  }
            ]]></artwork>
          </figure>
          <figure>
            <artwork><![CDATA[
  struct ConnectRequestV2 {
    sint32 protocolVersion
    sint64 lastZxidSeen
    sint32 timeOut
    sint64 sessionId
    byte[] passwd
    bool   readOnly
  }
            ]]></artwork>
          </figure>

          <t>The client MUST set protocolVersion to 0.</t>

          <t>For an initial connection with no existing session, the client MUST set lastZxidSeen to 0, it MUST set sessionId to 0, and it SHOULD set passwd to a 16-byte array of zeros.</t>

          <t>The client SHOULD set timeOut to a positive integer representing the desired duration for the client's session timeout, measured in milliseconds.</t>

          <t>TODO: what does readOnly mean?</t>

          <t>The server MAY respond with either ConnectResponseV1 or ConnectResponseV2 (preceded by its length, as described in <xref target="framing" />, and encoded with Jute, as described in <xref target="jute" />).</t>

          <figure>
            <artwork><![CDATA[
  struct ConnectResponseV1 {
    sint32 protocolVersion
    sint32 timeOut
    sint64 sessionId
    byte[] passwd
  }
            ]]></artwork>
          </figure>
          <figure>
            <artwork><![CDATA[
  struct ConnectResponseV2 {
    sint32 protocolVersion
    sint32 timeOut
    sint64 sessionId
    byte[] passwd
    bool   readOnly
  }
            ]]></artwork>
          </figure>

          <t>The server MUST set protocolVersion to 0.</t>

          <t>The server MUST set timeOut to a positive integer representing the actual duration of the client's session timeout, measured in milliseconds.</t>

          <t>The server MUST set sessionId to a positive integer which opaquely identifies the client's session. It SHOULD set passwd to a value that is difficult for other clients to guess, which SHOULD be 16 bytes in length.</t>

          <t>TODO: what does readOnly mean?</t>

          <t>After receiving a Connect Response, the client MAY issue requests, as described in <xref target="requests" />.</t>
        </section>

        <section title="Subsequent Connection Setup">
          <t>After its initial connection, the client may attempt to reconnect to any server while maintaining its session. To do so, it should send a Connect Request with the sessionId and passwd fields set to those provided by the server in the initial Connect Response.</t>

          <t>TODO: how does the server indicate session expired or bad password?</t>

          <t>Upon accepting a subsequent connection from a client, the servers SHOULD disconnect existing connections from that client. TODO: how do they notify?</t>
        </section>

        <section title="Session Expiration">
          <t>To maintian its session, a client MUST make requests more frequently than its session timeout. If a client has nothing to do, it SHOULD issue Ping requests, as described in <xref target="ping-request" />.</t>

          <t>The servers SHOULD expire a client's session if they have not received any requests from that client after the duration of its session timeout. They MAY grant the client additional grace period(s) beyond the client's session tiemout.</t>
        </section>
      </section>

      <section anchor="requests" title="Requests">
        <section anchor="ping-request" title="Ping">
        </section>

        <section title="Get Children">
          <section title="Get Children v1">
          </section>
          <section title="Get Children v2">
          </section>
        </section>

        <section title="Get Data">
        </section>

        <section title="Exists">
        </section>

        <section title="Create">
        </section>

        <section title="Delete">
        </section>

        <section title="Set Data">
        </section>

        <section title="Close">
        </section>

        <section title="Sync">
        </section>

        <section title="Set Watches">
        </section>

        <section title="Multi-Ops (Transactions)">
        </section>
      </section>

      <section anchor="notifications" title="Notifications">
      </section>

      <section anchor="IANA" title="IANA Considerations">
        <t>This memo includes no request to IANA.</t>
        <!--
        <t>All drafts are required to have an IANA considerations section (see
        <xref target="RFC5226">Guidelines for Writing an IANA Considerations Section in RFCs</xref> for a guide). If the draft does not require IANA to do
        anything, the section contains an explicit statement that this is the
        case (as above). If there are no requirements for IANA, the section will
        be removed during conversion into an RFC by the RFC Editor.</t>
      -->
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>All drafts are required to have a security considerations section.
        See <xref target="RFC3552">RFC 3552</xref> for a guide.</t>
      </section>
    </middle>

    <back>

      <references title="Normative References">
        &RFC2119;

        &RFC4422;

        &RFC7414;
      </references>

      <references title="Informative References">
        &RFC3552;

        &RFC5226;
      </references>

    </back>
  </rfc>
